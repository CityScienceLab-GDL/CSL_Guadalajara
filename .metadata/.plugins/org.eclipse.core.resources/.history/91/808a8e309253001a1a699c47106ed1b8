/**
 *  Social Fabric Model 
 *  Author: Gamaliel Palomo and Arnaud Grignard
 *  Description: Model for Social Fabric. This approach follows the idea that social interactions depend on the physical layer of an urban space. 
 * 				This means that if the infrastructure conditions (lightning, paving, etc) are good for an agent's perception, this will prefer to
 * 				walk through this space and it will feel confortable, and social interactions emerge as a result.
 */

model SocialFabric
global torus:false{

	//Initialization parameters 
	string case_study parameter: "Case study:" category: "Initialization" <-"sixcorners" among:["centinela", "miramar", "sixcorners"];
	int nbAgents parameter: "Number of people" category: "Initialization" <-0 min:0 max: 1000;
	int nbOffenders parameter: "Number of offenders" category: "Initialization" <-0 min:0 max: 100;
	bool allowstreetsKnowledge parameter: "Allow knoledge" category: "Initialization" <- false;
	int  cellSize parameter: 'Cells Size:' category: 'Initialization' <- 10 min: 5 max: 100;
	int offenderPerception parameter: 'Offender Perception Distance:' category: 'Model' <- 100 min: 10 max: 500;
	//Model parameters
	bool showInteractions parameter: "Show encounters" category:"Model" <- false;
	int interactionDistance parameter: "Interaction distance" category:"Model" <- 50 min: 50 max: 1000;
	float agentSpeed parameter: "Agents Speed" category: "Model" <- 1.4 min:0.5 max: 10.0;
	//Visualization parameters
	bool showCells parameter: "Insecurity perception" category:"Visualization" <- true;
	bool showPlace parameter: "Show Places" category: "Visualization" <- false;
	bool showPerception parameter: "Show perception" category: "Visualization" <- false;
	bool showBlocks parameter: "Show blocks" category:"Visualization" <- false;
	bool showNbCrime parameter: "Show Number of Crime" category: "Visualization" <-false;
	bool showOffenderTarget parameter: "Show Offender Target" category: "Visualization" <-false;
	bool showOffenderPath parameter: "Show Offender Path" category: "Visualization" <-false;

	
	int timeStep;
	graph street_network;
	map<street, float> weight_map;
	list<int> usedstreets;
	map<string, rgb> color_type <- ["offender"::rgb(255,255,0), "victim"::rgb (255, 0, 255), "people"::rgb (10, 192, 83,255)];
	
	//Crimes
	int totalCrimes;
	
	//Output variables
	int encounters;
	float maxEncounters;
	int negEncounters;
	float maxNegEncounters;
	int lights;
	int paving;
	int sideWalks;

	//Walkers
	int nbWalkers <- 0;
	int flux_node_size <- 20;
	list<flux_node> source_places <- [];
	list<flux_node> sink_places <- [];
	int fluxid <- 1;
	map<list<flux_node>,path> paths <- nil;
	graph<walker,walker> interaction_graph;

	date starting_date <- date("now");
	file streets_file <- file("/gis/"+case_study+"/roads.shp");
	geometry shape <- envelope(streets_file);
	init{
		
		file blocks_file <- nil;
		file block_fronts_file <- nil;
		file places_file <- nil;
		file interlands_file;
		
		string inputFileName <- "";
		
		inputFileName <- "/gis/"+case_study+"/blocks.shp";
		if file_exists(inputFileName){ blocks_file <- file(inputFileName);}
		
		inputFileName <- "/gis/"+case_study+"/block_fronts.shp";
		if file_exists(inputFileName){ block_fronts_file <- file(inputFileName);}
		
		inputFileName <- "/gis/"+case_study+"/places.shp";
		if file_exists(inputFileName){ places_file <- file(inputFileName);}
		
		inputFileName <- "/gis/"+case_study+"/interlands.shp";
		if file_exists(inputFileName){ interlands_file <- file(inputFileName);}
		
		
		
		create block from:blocks_file with:[blockID::string(read("CVEGEO")), str_lightning::string(read("ALUMPUB_C")), str_paving::string(read("RECUCALL_C")), str_sidewalk::string(read("BANQUETA_C")), str_access::string(read("ACESOPER_C")), str_trees::string(read("ARBOLES_C"))]{
			if str_lightning = "Todas las vialidades"{ int_lightning <- 2; }
			else if str_lightning = "Alguna vialidad"{ int_lightning <- 1; }
			else{ int_lightning <- 0; }
			if str_paving = "Todas las vialidades"{ int_paving <- 2; }
			else if str_paving = "Alguna vialidad"{ int_paving <- 1; }
			else{ int_paving <- 0; }
			if str_sidewalk = "Todas las vialidades"{ int_sidewalk <- 2; }
			else if str_sidewalk = "Alguna vialidad"{ int_sidewalk <- 1; }
			else{ int_sidewalk <- 0; }
			if str_access = "Restricción en ninguna vialidad"{ int_access <- 2; }
			else if str_access = "Restricción en alguna vialidad"{ int_access <- 1; }
			else{ int_access <- 0; }
			if str_trees = "Todas las vialidades"{ int_trees <- 2; }
			else if str_trees = "Alguna vialidad"{ int_trees <- 1; }
			else{ int_trees <- 0; }
			do updateValuation;
		}
		create block_front from:block_fronts_file with:[block_frontID::string(read("CVEGEO")), street_id::int(read("CVEVIAL")),int_lightning::int(read("ALUMPUB_")), int_paving::int(read("RECUCALL_")), int_sideWalk::int(read("BANQUETA_")), int_access::int(read("ACESOPER_"))]{ do init_condition; }
		do mapValues;
		create street from:streets_file{ do init_condition;	}
		
		create places from: interlands_file with:[type::"interland"]{do interactWithStreets;}
		create places from: places_file with:[id::string(read("id")),name_str::string(read("nom_estab"))];			
		weight_map <- street as_map(each::each.valuation);
		street_network <- as_edge_graph(street);
		usedstreets <- list_with(length(street_network),-1);
		create inhabitant number:nbAgents;
		create offender number:nbOffenders;
	
		create flux_node from: file("/gis/"+case_study+"/flux.shp") with:[id::int(read("id")),way::string(read("way"))];
		if length(flux_node where(each.way="input"))=0{
			create flux_node with:[id::-1,way::"input",location::one_of(street_network.vertices)]{fluxid<-fluxid+1;}
		}
		if length(flux_node where(each.way="output"))=0{
			create flux_node with:[id::0,way::"output",location::one_of(street_network.vertices)]{fluxid<-fluxid+1;}
		}
		
		totalCrimes<-0;
		maxEncounters <- nbAgents*(nbAgents-1)/2;
		maxNegEncounters <- nbOffenders*(nbOffenders-1)/2;
		write "Total of places: "+length(places);
		write "Total of streets: "+length(street); 
	}
	
	reflex main{
		create walker number:4;
	}
	reflex updateGraph when: (showInteractions = true) {
		interaction_graph <- graph<walker, walker>(walker as_distance_graph (interactionDistance));
	}
	user_command "source_place here"{
		point newPoint <- #user_location;
		create flux_node with:[id::fluxid,way::"input",location::newPoint]{fluxid<-fluxid+1;}
	}
	user_command "sink_place here"{
		point newPoint <- #user_location;
		create flux_node with:[id::fluxid,way::"output",location::newPoint]{fluxid<-fluxid+1;}
	}
	user_command "interland"{
		create places{
			type <- "interland";
			location <- #user_location;
			do interactWithStreets;
		}
		weight_map <- street as_map(each::each.valuation);
		do rebuildPaths;
	}
	action rebuildPaths{
		loop keylist over:paths.keys{
			put path_between(street_network with_weights weight_map, keylist[0], keylist[1]) at:keylist in:paths;
		}
	}
	action mapValues{
	//Information about streets condition is in block fronts file, copy it to street species.
		loop bf_element over:block_front{
			int st_id <- bf_element.street_id;
			list<street> auxStreets <- street where (each.street_id = st_id);
			if(auxStreets!=[]){
				ask auxStreets{
					float_lightning <- bf_element.int_lightning/2;
					float_paving <- bf_element.int_paving/2;
					float_sideWalk <- bf_element.int_sideWalk/2;
					float_access <- bf_element.int_access/2;
				}
			}
		}
	}
}

species flux_node{
	int id;
	string way;
	aspect default{
		//draw way="input"?square(flux_node_size):triangle(flux_node_size) color:way="input"?#mediumseagreen:#crimson;
		draw square(flux_node_size) color:#mediumseagreen;
	}
}

species flux_node_ mirrors:flux_node{
	aspect default{
		draw circle(15) color:rgb (77, 107, 251,255);
	}
}

species street{
	int street_id;
	float valuation;
	float weight;
	float float_lightning;
	float float_paving;
	float float_sideWalk;
	float float_access;
	action init_condition{
		valuation <- (float_lightning+float_paving+float_sideWalk+float_access)/4;
		weight <- valuation; //Normalization of valuation 0 to 1 according to the model
		weight <- 100*(1 - weight); //In weighted networks, a path is shorter than other if it has smaller value. 0 <- best street, 1 <- worst street
	}
	//aspect default{draw shape color: rgb(255-(127*valuation),0+(127*valuation),50,255);}
	aspect default{draw shape color: rgb(0+(255*valuation),50,50,100);}
	aspect gray{draw shape color: rgb (174, 174, 174,200);}
}

species block{
	string blockID;
	string str_lightning;
	string str_sidewalk;
	string str_paving;
	string str_access;
	string str_trees;
	int int_lightning;
	int int_sidewalk;
	int int_paving;
	int int_access;
	int int_trees;
	float valuation;
	float heigth;
	init{
		heigth <- float(rnd(10));
	}
	action updateValuation{
		int sum <- int_lightning+int_sidewalk+int_paving+(1-int_access)+int_trees;
		valuation <- sum/5;
	}
	aspect default{	if(showBlocks){draw shape depth:heigth color: rgb(255-(127*valuation),0+(127*valuation),50,180);}}
	aspect simple{ draw shape color: rgb (218, 179, 61,120);}
}

species block_front{
	int street_id;
	string block_frontID;
	int int_lightning;
	int int_paving;
	int int_sideWalk;
	int int_access;
	float valuation;
	string street_name;
	action init_condition{
		if int_lightning = 1 { int_lightning <-2; }
			else if int_lightning = 2 { int_lightning <- 0; }
			else{ int_lightning <- 1; }
			if int_paving = 1 or int_paving = 2 { int_paving <- 2; }
			else if int_paving = 2 { int_paving <- 0; }
			else{ int_paving <- 1; }
			if int_sideWalk = 1 {int_sideWalk <- 2;}
			else if int_sideWalk = 2 {int_sideWalk <- 0;}
			else {int_sideWalk <- 1;}
			if int_access = 2 {int_access <- 2;}
			else {int_access <- 0;}
			do init_Valuation;
	}
	action init_Valuation{
		valuation <- 0.0;
		int sum <- int_lightning + int_paving + int_sideWalk + int_access;
		valuation <- sum / 4;  
	}
	aspect default{	draw shape color: rgb(255-(127*int_lightning),0+(127*int_lightning),50,255); }
}

species places{
	string id;
	string name_str;
	float height;
	string type;
	init{ height <- float(50+rnd(100)); }
	aspect default{ 
		if(showPlace){
		  draw geometry:square(50#m)  color:rgb (86, 140, 158,255) border:#indigo depth:height;	
		}
	}
	aspect interland{
		if type="interland"{draw square(flux_node_size) color: rgb (232, 64, 126,255) border: #maroon;}
	}
	action interactWithStreets{
		list<street> inRank <- [];
		inRank <- street at_distance(50);
		if length(inRank)!=0{
			ask inRank{
				valuation <- 100.0;
			}
		}
	}
}

species targets{ aspect name:default{ draw geometry:triangle(100#m) color:rgb("red");  } }

grid cell width:world.shape.width/cellSize height:world.shape.height/cellSize{
	int current_people_inside;
	//insecurity_perception is refered as the perception of security, and its value depends on social and environmental factors 
	// such as crimes commited and physical layer conditions. 
	int insecurity_perception; 
	int max_insecurity_perception <- 100;
	rgb insecurity_perception_color <- rgb(255,255,255);
	float transparency <- 0.0;
				 
	init{
		current_people_inside <- 0;
		insecurity_perception <- 0;
	}
	reflex update_color when:showCells{
		insecurity_perception_color <- rgb(transparency*155,transparency*10,transparency*10);
	}
	reflex update_transparency when:showCells{
		transparency <- float(insecurity_perception)/max_insecurity_perception;
	}
	action updateNbPeople {
		current_people_inside <- length(inhabitant inside self);
	}
	aspect insecurity_perception{
		if(showCells){
			draw shape color:rgb(insecurity_perception_color,transparency) border:rgb(insecurity_perception_color,transparency) empty:true;
		}
	}
	aspect crimeAttractiveAreas{
		draw shape color:rgb(current_people_inside*100, 0,0,128) border:rgb(current_people_inside*100, 0, 0, 128);	
	}
}

species offender skills:[moving] parent: people edge_species:negRelationships parallel:true{

	string state <- "Arrived" ;
	int attractivityThreshold;
	int nbCrimeCommited;
	int timeWaiting;
	int maxWaitingTime<-50;
	list<inhabitant> victims;
	init{
		routineCount <- 0;
		streets_knowledge <- weight_map;
		nbCrimeCommited<-0;
		attractivityThreshold <- rnd(1,5);
		speed <- agentSpeed;
		do buildRoutine;
		do updateTarget;
		loop while: shortestPath = nil or shortestPath = []{
			routine[routineCount] <- places[rnd(length(places)-1)];
			target <- routine[routineCount].location;
			do updateShortestPath;
		}
		create targets{ location <- myself.target; }	
	}
	action move{
		if state="OnTheWay"{
			if location = target{state <- "Arrived";}
			else{do moveForward;}
		}
		else if state="WaitingToCommitCrime"{
			inhabitant victim <- one_of(inhabitant at_distance(offenderPerception));
			if(victim != nil){
				do commitCrime(victim);
				state <- "InRoutine";
			}
			if timeWaiting>=maxWaitingTime{state<-"InRoutine";}
			timeWaiting <- timeWaiting + 1;
		}
		else if state="Arrived"{
			if(flip(0.5)){timeWaiting<-0;state <- "WaitingToCommitCrime";}
			else{state <- "InRoutine";}
		}
		else if state="InRoutine"{
			do updateTarget;
			loop while: shortestPath = nil or shortestPath = []{
				routine[routineCount] <- places[rnd(length(places)-1)];
				target <- routine[routineCount].location;
				do updateShortestPath;
			}
			ask targets{ location<-myself.target; }
			state <- "OnTheWay";
		}
	}
	action commitCrime(inhabitant victim){
		cell currentCell <- cell closest_to(self);
		victim.victimized <- true;
		currentCell.insecurity_perception <- currentCell.insecurity_perception + 1;
		totalCrimes <- totalCrimes + 1;
		nbCrimeCommited<-nbCrimeCommited+1;
		add victim to:victims;
	}
	aspect default{
		if (state="onTheWay"){ draw circle(25) color:color_type["offender"];}
		else{draw circle(10) color:color_type["offender"];}
		if(showPerception){
			draw circle(offenderPerception) empty:true color:#red;
			draw circle(offenderPerception) color:rgb(255,0,0,0.5);
		}
		if(showNbCrime){
			draw "crime:" + nbCrimeCommited size:6#px color:#white;
		}
		if(showOffenderTarget){
			draw line(location,target) width:0.5 color:color_type["offender"];
		}
		if(showOffenderPath){
	 	 	draw current_path.shape color: color_type["offender"];
		}
	}	
	action moveForward{
		speed <- agentSpeed;
		do follow path:shortestPath move_weights: shortestPath.edges as_map(each::each.perimeter);
		if(location = target){
			do updateTarget;
			loop while: shortestPath = nil or shortestPath = []{
				routine[routineCount] <- places[rnd(length(places)-1)];
				target <- routine[routineCount].location;
				do updateShortestPath;
			}
			ask targets{ location<-myself.target; }
		}
	}
}

species inhabitant skills:[moving] parent: people edge_species: relationships parallel:true{
	init{
		routineCount <- 0;
		streets_knowledge <- weight_map;
		do buildRoutine;
		do updateTarget;
		loop while: shortestPath = nil or shortestPath = []{
			routine[routineCount] <- places[rnd(length(places)-1)];
			target <- routine[routineCount].location;
			do updateShortestPath;
		}
		create targets{ location <- myself.target; }
	}
	action move{
		speed <- agentSpeed;
		do follow path:shortestPath move_weights: shortestPath.edges as_map(each::each.perimeter);
		if(location = target){
			do updateTarget;
			loop while: shortestPath = nil or shortestPath = []{
				routine[routineCount] <- places[rnd(length(places)-1)];
				target <- routine[routineCount].location;
				do updateShortestPath;
			}
			ask targets{ location<-myself.target; }
		}
	}
}

species people  parent: graph_node edge_species: relationships{
	int routineCount;
	point target;
	path shortestPath;
	bool victimized;
	map<street, float> streets_knowledge;
	list<places> routine;

	bool related_to(people other){
	  	using topology:topology(world) {return (self.location distance_to other.location < interactionDistance);}
	}
	
	action buildRoutine{
		int tmpRnd <- rnd(length(places)-1);
		add places[tmpRnd] to:routine;
		location <- routine[0].location;
		loop times: 2{
			seed <- rnd(100.0);
			tmpRnd <- rnd(length(places)-1);
			add places[tmpRnd] to: routine;
		}
	}
	action updateTarget{
		if length(routine)-1 = routineCount{
			target <- routine[0].location;
			routineCount <- 0;
		}else{
			routineCount <- routineCount + 1;
			target <- routine[routineCount].location;	
		}
		do updateShortestPath;
	}
	action updateShortestPath{
		if allowstreetsKnowledge{ shortestPath <- path_between(street_network with_weights streets_knowledge, location, target); }
		else{ shortestPath <- path_between(street_network, location, target); }
	}

	aspect default{
		if (victimized = true){
	      draw circle(35) color:color_type["victim"] ;
		}
		else{
		  draw circle(15) color:color_type["people"];	
		}
	}
}

species walker skills:[moving]{
	point target;
	path shortest;
	init{
		flux_node source_place <- one_of(flux_node);
		location <- source_place.location;
		flux_node sink_place <- one_of(flux_node);
		target <- sink_place.location;
		if(paths[[source_place,sink_place]] != nil){shortest<-paths[[source_place,sink_place]];}
		else{
			path newPath <- path_between(street_network, location, target);
			add [source_place,sink_place]::newPath to: paths;
			shortest <- newPath;
		}
	}
	aspect default{
		draw circle(1.5) color: rgb (255, 255, 0,200);
	}
	reflex moving{
		if(location = target){do die;}
		speed <- 5*agentSpeed;
		do follow path:shortest move_weights: shortest.edges as_map(each::each.perimeter);
		do update_insecurity_map;
	}
	action update_insecurity_map{
		list<cell> tmp <- cell overlapping(shape);
		if(tmp!=[]){
			ask tmp{
				insecurity_perception <- insecurity_perception+1;
				if(insecurity_perception>max_insecurity_perception){
					insecurity_perception <- max_insecurity_perception;
				}
			}
		}
	}
}

species relationships parent: base_edge {aspect default {if showInteractions{draw shape color:#blue;}}}
species negRelationships parent: base_edge {aspect default {if showInteractions{draw shape color:#red;}}}

experiment Fluxes type:gui parallel:false {
	
	output{
		
		layout #split;
		display environment background:#black type:opengl draw_env:false name:"Tejido Social"{
			graphics "network" refresh:false{
				loop vertex over: street_network.vertices{
					draw circle(10) at:point(vertex) color: rgb (68, 151, 183,100);
				}
			}
			graphics "interaction_graph" {
				if (interaction_graph != nil and (showInteractions = true)) {
					loop eg over: interaction_graph.edges {
						walker src <- interaction_graph source_of eg;
						walker target <- interaction_graph target_of eg;
						geometry edge_geom <- geometry(eg);
						draw line(edge_geom.points) color: rgb(0, 125, 0, 75);
					}
				}

			}
			//species street aspect:default;
			species block aspect:default;
			species walker aspect:default trace:0;
			species places aspect:interland;
			overlay position: { 10, 10 } size: { 180 #px, 180 #px } background: # black transparency: 0.5 border: #black rounded: true{
                float y <- 30#px;
                draw "Agents: " +  length(walker) at: { 40#px, y + 4#px } color: #white font: font("SansSerif", 15);
				draw square(flux_node_size) color:#mediumseagreen at:{50#px, y+30#px};
				draw "Flux I/O" at:{50+30#px, y+30#px}  color: #white font: font("SansSerif", 15);
				draw square(flux_node_size) at:{50#px, y+60#px} color: rgb (232, 64, 126,255) border: #maroon;
				draw "Interland" at:{50+30#px, y+60#px}  color: #white font: font("SansSerif", 15);
				draw "Tejido Social" at:{600#px, 10#px} color: #white font: font("SansSerif", 25);
            }
            species flux_node aspect:default;
            species cell aspect:insecurity_perception;
		}
		
		display network background:#black type:opengl name:"Network analysis" draw_env:false{
			graphics "nodes"{
            	point reference <- location;
            	map<flux_node,flux_node_> location_translation;
            	int diameter <- 300;
            	int n <- length(flux_node);
            	float alpha <- 360/n;
            	loop it from: 0 to:n-1{
            		point point_location <- (location+{diameter*cos(alpha*it),diameter*sin(alpha*it)});
            		ask flux_node_[it]{location <- point_location;}
            		add flux_node[it]::flux_node_[it] to:location_translation;
            	}
            	loop key over:paths.keys{
            		geometry edge <- curve(location_translation[key[0]].location,location_translation[key[1]].location, 0.5, 200, 90);
            		draw edge color:#green;
	            }
			}
			species flux_node_ aspect:default;
		}	
	}
}

experiment GUI type:gui{
	parameter "streets_Knowledge" var: allowstreetsKnowledge  <- false;
	output{
		layout #split;
		display Main type:opengl ambient_light:50{
			species block aspect:default;
			species inhabitant aspect:default;
			species relationships aspect:default;
			species negRelationships aspect:default;
			species places aspect:default;
			species offender;
			overlay position: { 5, 5 } size: { 180 #px, 200 #px } background: # black transparency: 0.5 border: #black rounded: true
            {
				float y <- 30#px;
				loop type over: color_type.keys
				{
					draw circle(5#px) at: { 20#px, y } color: color_type[type] border: color_type[type]+1;
					draw string(type) at: { 40#px, y + 4#px } color: #white font: font("SansSerif", 12);
   					y <- y + 25#px;
               }
   				draw "Crimes: " +  totalCrimes at: { 40#px, y + 4#px } color: #white font: font("SansSerif", 15);
            }
		}
		display Output type:opengl{
			chart "Social Fabric" type: radar position:{5,5} background: # black x_serie_labels: [ "+ Encounters", "- Encounters", "+ Safety perception", "- Safety perception", "Segregation"] color:#white series_label_position: xaxis
			{
				data "Encounters" value: [encounters/maxEncounters,negEncounters/maxNegEncounters,0.1,0.1,0.1] color: # green;
			}
		}
		display Risk_Areas type:opengl{
			species cell aspect: crimeAttractiveAreas;
			species street aspect:default refresh:false;
		}
		
	}
}