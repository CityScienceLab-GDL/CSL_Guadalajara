/**
 *  Social Fabric Model 
 *  Author: Gamaliel Palomo and Arnaud Grignard
 *  Description: Model for Social Fabric. This approach follows the idea that social interactions depend on the physical layer of an urban space. 
 * 				This means that if the infrastructure conditions (lightning, paving, etc) are good for an agent's perception, this will prefer to
 * 				walk through this space and it will feel confortable, and social interactions emerge as a result.
 */

model SocialFabric
global torus:false{

	//Initialization parameters 
	string case_study parameter: "Case study:" category: "Initialization" <-"sixcorners" among:["centinela", "miramar", "sixcorners"];
	int nbAgents parameter: "Number of people" category: "Initialization" <-0 min:50 max: 1000;
	int nbOffenders parameter: "Number of offenders" category: "Initialization" <-0 min:0 max: 100;
	bool allowRoadsKnowledge parameter: "Allow knoledge" category: "Initialization" <- false;
	int  cellSize parameter: 'Cells Size:' category: 'Initialization' <- 500 min: 50 max: 1000;
	int offenderPerception parameter: 'Offender Perception Distance:' category: 'Model' <- 100 min: 10 max: 500;
	//Model parameters
	bool showInteractions parameter: "Show encounters" category:"Model" <- false;
	int interactionDistance parameter: "Interaction distance" category:"Model" <- 50 min: 50 max: 1000;
	float agentSpeed parameter: "Agents Speed" category: "Model" <- 1.4 min:0.5 max: 10.0;
	//Visualization parameters
	bool showPlace parameter: "Show Places" category: "Visualization" <- false;
	bool showPerception parameter: "Show perception" category: "Visualization" <- false;
	bool showBlocks parameter: "Show blocks" category:"Visualization" <- false;
	bool showNbCrime parameter: "Show Number of Crime" category: "Visualization" <-false;
	bool showOffenderTarget parameter: "Show Offender Target" category: "Visualization" <-false;
	bool showOffenderPath parameter: "Show Offender Path" category: "Visualization" <-false;
	
	int timeStep;
	graph road_network;
	map<road, float> weight_map;
	list<int> usedRoads;
	map<string, rgb> color_type <- ["offender"::rgb(255,255,0), "victim"::rgb (255, 0, 255), "people"::rgb (10, 192, 83,255)];
	
	//Crimes
	int totalCrimes;
	
	//Output variables
	int encounters;
	float maxEncounters;
	int negEncounters;
	float maxNegEncounters;
	int lights;
	int paving;
	int sideWalks;

	//Walkers
	int nbWalkers <- 0;
	int flux_node_size <- 20;
	list<flux_node> source_places <- [];
	list<flux_node> sink_places <- [];
	int fluxid <- 1;
	map<list<flux_node>,path> paths <- nil;

	date starting_date <- date("now");
	file roads_file <- file("/gis/"+case_study+"/roads.shp");
	geometry shape <- envelope(roads_file);
	init{
		
		file blocks_file <- nil;
		file block_fronts_file <- nil;
		file places_file <- nil;
		
		string inputFileName <- "";
		
		inputFileName <- "/gis/"+case_study+"/blocks.shp";
		if file_exists(inputFileName){ blocks_file <- file(inputFileName);}
		
		inputFileName <- "/gis/"+case_study+"/block_fronts.shp";
		if file_exists(inputFileName){ block_fronts_file <- file(inputFileName);}
		
		inputFileName <- "/gis/"+case_study+"/places.shp";
		if file_exists(inputFileName){ places_file <- file(inputFileName);}
		
		
		
		create block from:blocks_file with:[blockID::string(read("CVEGEO")), str_lightning::string(read("ALUMPUB_C")), str_paving::string(read("RECUCALL_C")), str_sidewalk::string(read("BANQUETA_C")), str_access::string(read("ACESOPER_C")), str_trees::string(read("ARBOLES_C"))]{
			if str_lightning = "Todas las vialidades"{ int_lightning <- 2; }
			else if str_lightning = "Alguna vialidad"{ int_lightning <- 1; }
			else{ int_lightning <- 0; }
			if str_paving = "Todas las vialidades"{ int_paving <- 2; }
			else if str_paving = "Alguna vialidad"{ int_paving <- 1; }
			else{ int_paving <- 0; }
			if str_sidewalk = "Todas las vialidades"{ int_sidewalk <- 2; }
			else if str_sidewalk = "Alguna vialidad"{ int_sidewalk <- 1; }
			else{ int_sidewalk <- 0; }
			if str_access = "Restricción en ninguna vialidad"{ int_access <- 2; }
			else if str_access = "Restricción en alguna vialidad"{ int_access <- 1; }
			else{ int_access <- 0; }
			if str_trees = "Todas las vialidades"{ int_trees <- 2; }
			else if str_trees = "Alguna vialidad"{ int_trees <- 1; }
			else{ int_trees <- 0; }
			do updateValuation;
		}
		create block_front from:block_fronts_file with:[block_frontID::string(read("CVEGEO")), int_lightning::int(read("ALUMPUB_")), int_paving::int(read("RECUCALL_")), int_sideWalk::int(read("BANQUETA_")), int_access::int(read("ACESOPER_"))]{ do init_condition; }
		create road from:roads_file{ do init_condition;	}
		create places from: places_file with:[id::string(read("id")),name_str::string(read("nom_estab"))];			
		weight_map <- road as_map(each::each.valuation);
		road_network <- as_edge_graph(road);
		usedRoads <- list_with(length(road_network),-1);
		create inhabitant number:nbAgents;
		create offender number:nbOffenders;
	
		create flux_node from: file("/gis/"+case_study+"/flux.shp") with:[id::int(read("id")),way::string(read("way"))];
		if length(flux_node where(each.way="input"))=0{
			create flux_node with:[id::-1,way::"input",location::one_of(road_network.vertices)]{fluxid<-fluxid+1;}
		}
		if length(flux_node where(each.way="output"))=0{
			create flux_node with:[id::0,way::"output",location::one_of(road_network.vertices)]{fluxid<-fluxid+1;}
		}
		
		totalCrimes<-0;
		maxEncounters <- nbAgents*(nbAgents-1)/2;
		maxNegEncounters <- nbOffenders*(nbOffenders-1)/2;
		write "Total of places: "+length(places);
		write "Total of roads: "+length(road); 
	}
	
	reflex main when:mod(cycle,1)=0{
		create walker number:2;
	}
	user_command "source_place here"{
		point newPoint <- #user_location;
		create flux_node with:[id::fluxid,way::"input",location::newPoint]{fluxid<-fluxid+1;}
	}
	user_command "sink_place here"{
		point newPoint <- #user_location;
		create flux_node with:[id::fluxid,way::"output",location::newPoint]{fluxid<-fluxid+1;}
	}
	user_command "interland"{
		create places{
			type <- "interland";
			location <- #user_location;
			do interactWithStreets;
		}
		weight_map <- road as_map(each::each.valuation);
		do rebuildPaths;
	}
	action rebuildPaths{
		loop keylist over:paths.keys{
			put path_between(road_network with_weights weight_map, keylist[0], keylist[1]) at:keylist in:paths;
		}
	}
}

species flux_node{
	int id;
	string way;
	aspect default{
		//draw way="input"?square(flux_node_size):triangle(flux_node_size) color:way="input"?#limegreen:#crimson;
		draw square(flux_node_size) color:#limegreen;
	}
}

species road{
	string road_name;
	float valuation;
	float weight;
	int int_lightning;
	int int_paving;
	int int_sideWalk;
	int int_access;
	action init_condition{
		valuation <- 0.0;
		list nearBlockFronts;
		nearBlockFronts <- block_front at_distance(50);
		if length(nearBlockFronts)>0{
			block_front tmpBlockFront <- one_of(nearBlockFronts);
			valuation <- tmpBlockFront.valuation;
			int_lightning <- tmpBlockFront.int_lightning;
			int_paving <- tmpBlockFront.int_paving;
			int_sideWalk <- tmpBlockFront.int_sideWalk;
			int_access <- tmpBlockFront.int_access;
			if int_access = 0{valuation <- 0.0;}
		}
		weight <- valuation / 2; //Normalization of valuation 0 to 1 according to the model
		weight <- 100*(1 - weight); //In weighted networks, a path is shorter than other if it has smaller value. 0 <- best road, 1 <- worst road
	}
	//aspect default{draw shape color: rgb(255-(127*valuation),0+(127*valuation),50,255);}
	aspect default{draw shape color: rgb(0+(255*valuation),50,50,100);}
	aspect gray{draw shape color: rgb (174, 174, 174,200);}
}

species block{
	string blockID;
	string str_lightning;
	string str_sidewalk;
	string str_paving;
	string str_access;
	string str_trees;
	int int_lightning;
	int int_sidewalk;
	int int_paving;
	int int_access;
	int int_trees;
	float valuation;
	action updateValuation{
		int sum <- int_lightning+int_sidewalk+int_paving+(1-int_access)+int_trees;
		valuation <- sum/5;
	}
	aspect default{	if(showBlocks){draw shape color: rgb(255-(127*valuation),0+(127*valuation),50,180);}}
	aspect simple{ draw shape color: rgb (218, 179, 61,120);}
}

species block_front{
	string block_frontID;
	int int_lightning;
	int int_paving;
	int int_sideWalk;
	int int_access;
	float valuation;
	action init_condition{
		if int_lightning = 1 { int_lightning <-2; }
			else if int_lightning = 2 { int_lightning <- 0; }
			else{ int_lightning <- 1; }
			if int_paving = 1 or int_paving = 2 { int_paving <- 2; }
			else if int_paving = 2 { int_paving <- 0; }
			else{ int_paving <- 1; }
			if int_sideWalk = 1 {int_sideWalk <- 2;}
			else if int_sideWalk = 2 {int_sideWalk <- 0;}
			else {int_sideWalk <- 1;}
			if int_access = 2 {int_access <- 2;}
			else {int_access <- 0;}
			do init_Valuation;
	}
	action init_Valuation{
		valuation <- 0.0;
		int sum <- int_lightning + int_paving + int_sideWalk + int_access;
		valuation <- sum / 4;  
	}
	aspect default{	draw shape color: rgb(255-(127*int_lightning),0+(127*int_lightning),50,255); }
}

species places{
	string id;
	string name_str;
	float height;
	string type;
	init{ height <- float(50+rnd(100)); }
	aspect default{ 
		if(showPlace){
		  draw geometry:square(50#m)  color:rgb (86, 140, 158,255) border:#indigo depth:height;	
		}
	}
	aspect interland{
		if type="interland"{draw square(flux_node_size) color: rgb (232, 64, 126,255) border: #maroon;}
	}
	action interactWithStreets{
		list<road> inRank <- [];
		inRank <- road at_distance(50);
		write "Interacting with: \n"+inRank;
		if length(inRank)!=0{
			ask inRank{
				valuation <- 100.0;
			}
		}
	}
}

species targets{ aspect name:default{ draw geometry:triangle(100#m) color:rgb("red");  } }

grid cell width:world.shape.width/cellSize height:world.shape.height/cellSize parallel:true{
	int current_people_inside;
	//Tension is refered as the perception of security, and its value depends on social and environmental factors 
	// such as crimes commited and physical layer conditions. 
	int tension; 
				 
	init{
		current_people_inside <- 0;
		tension <- 0;
	}
	reflex updateNbPeople when:mod(cycle,10)=0{
		current_people_inside <- length(inhabitant inside self);
	}
	aspect crimeAttractiveAreas{
		draw shape color:rgb(current_people_inside*100, 0,0,128) border:rgb(current_people_inside*100, 0, 0, 128);	
	}
	aspect tension{
		draw shape color:rgb(tension*50, 0, 0) border:rgb(tension*50, 0, 0) empty:false;
	}
}

species offender skills:[moving] parent: people edge_species:negRelationships parallel:true{

	string state <- "Arrived" ;
	int attractivityThreshold;
	int nbCrimeCommited;
	int timeWaiting;
	int maxWaitingTime<-50;
	list<inhabitant> victims;
	init{
		routineCount <- 0;
		roads_knowledge <- weight_map;
		nbCrimeCommited<-0;
		attractivityThreshold <- rnd(1,5);
		speed <- agentSpeed;
		do buildRoutine;
		do updateTarget;
		loop while: shortestPath = nil or shortestPath = []{
			routine[routineCount] <- places[rnd(length(places)-1)];
			target <- routine[routineCount].location;
			do updateShortestPath;
		}
		create targets{ location <- myself.target; }	
	}
	reflex move{
		if state="OnTheWay"{
			if location = target{state <- "Arrived";}
			else{do moveForward;}
		}
		else if state="WaitingToCommitCrime"{
			inhabitant victim <- one_of(inhabitant at_distance(offenderPerception));
			if(victim != nil){
				do commitCrime(victim);
				state <- "InRoutine";
			}
			if timeWaiting>=maxWaitingTime{state<-"InRoutine";}
			timeWaiting <- timeWaiting + 1;
		}
		else if state="Arrived"{
			if(flip(0.5)){timeWaiting<-0;state <- "WaitingToCommitCrime";}
			else{state <- "InRoutine";}
		}
		else if state="InRoutine"{
			do updateTarget;
			loop while: shortestPath = nil or shortestPath = []{
				routine[routineCount] <- places[rnd(length(places)-1)];
				target <- routine[routineCount].location;
				do updateShortestPath;
			}
			ask targets{ location<-myself.target; }
			state <- "OnTheWay";
		}
	}
	action commitCrime(inhabitant victim){
		cell currentCell <- cell closest_to(self);
		victim.victimized <- true;
		currentCell.tension <- currentCell.tension + 1;
		totalCrimes <- totalCrimes + 1;
		nbCrimeCommited<-nbCrimeCommited+1;
		add victim to:victims;
	}
	aspect default{
		if (state="onTheWay"){ draw circle(25) color:color_type["offender"];}
		else{draw circle(10) color:color_type["offender"];}
		if(showPerception){
			draw circle(offenderPerception) empty:true color:#red;
			draw circle(offenderPerception) color:rgb(255,0,0,0.5);
		}
		if(showNbCrime){
			draw "crime:" + nbCrimeCommited size:6#px color:#white;
		}
		if(showOffenderTarget){
			draw line(location,target) width:0.5 color:color_type["offender"];
		}
		if(showOffenderPath){
	 	 	draw current_path.shape color: color_type["offender"];
		}
	}	
	action moveForward{
		speed <- agentSpeed;
		do follow path:shortestPath move_weights: shortestPath.edges as_map(each::each.perimeter);
		if(location = target){
			do updateTarget;
			loop while: shortestPath = nil or shortestPath = []{
				routine[routineCount] <- places[rnd(length(places)-1)];
				target <- routine[routineCount].location;
				do updateShortestPath;
			}
			ask targets{ location<-myself.target; }
		}
	}
}

species inhabitant skills:[moving] parent: people edge_species: relationships parallel:true{
	init{
		routineCount <- 0;
		roads_knowledge <- weight_map;
		do buildRoutine;
		do updateTarget;
		loop while: shortestPath = nil or shortestPath = []{
			routine[routineCount] <- places[rnd(length(places)-1)];
			target <- routine[routineCount].location;
			do updateShortestPath;
		}
		create targets{ location <- myself.target; }
	}
	reflex move when:mod(cycle,2)=0{
		speed <- agentSpeed;
		do follow path:shortestPath move_weights: shortestPath.edges as_map(each::each.perimeter);
		if(location = target){
			do updateTarget;
			loop while: shortestPath = nil or shortestPath = []{
				routine[routineCount] <- places[rnd(length(places)-1)];
				target <- routine[routineCount].location;
				do updateShortestPath;
			}
			ask targets{ location<-myself.target; }
		}
	}
}

species people  parent: graph_node edge_species: relationships{
	int routineCount;
	point target;
	path shortestPath;
	bool victimized;
	map<road, float> roads_knowledge;
	list<places> routine;

	bool related_to(people other){
	  	using topology:topology(world) {return (self.location distance_to other.location < interactionDistance);}
	}
	
	action buildRoutine{
		int tmpRnd <- rnd(length(places)-1);
		add places[tmpRnd] to:routine;
		location <- routine[0].location;
		loop times: 2{
			seed <- rnd(100.0);
			tmpRnd <- rnd(length(places)-1);
			add places[tmpRnd] to: routine;
		}
	}
	action updateTarget{
		if length(routine)-1 = routineCount{
			target <- routine[0].location;
			routineCount <- 0;
		}else{
			routineCount <- routineCount + 1;
			target <- routine[routineCount].location;	
		}
		do updateShortestPath;
	}
	action updateShortestPath{
		if allowRoadsKnowledge{ shortestPath <- path_between(road_network with_weights roads_knowledge, location, target); }
		else{ shortestPath <- path_between(road_network, location, target); }
	}

	aspect default{
		if (victimized = true){
	      draw circle(35) color:color_type["victim"] ;
		}
		else{
		  draw circle(15) color:color_type["people"];	
		}
	}
}

species walker skills:[moving]{
	point target;
	path shortest;
	init{
		flux_node source_place <- one_of(flux_node);
		location <- source_place.location;
		flux_node sink_place <- one_of(flux_node);
		target <- sink_place.location;
		if(paths[[source_place,sink_place]] != nil){shortest<-paths[[source_place,sink_place]];}
		else{
			path newPath <- path_between(road_network, location, target);
			add [source_place,sink_place]::newPath to: paths;
			shortest <- newPath;
		}
	}
	aspect default{
		draw circle(1.5) color: rgb (255, 255, 0,200);
	}
	reflex moving{
		if(location = target){do die;}
		speed <- 5*agentSpeed;
		do follow path:shortest move_weights: shortest.edges as_map(each::each.perimeter);
	}
}

species relationships parent: base_edge {aspect default {if showInteractions{draw shape color:#blue;}}}
species negRelationships parent: base_edge {aspect default {if showInteractions{draw shape color:#red;}}}

experiment RoadGraph type:gui{
	output{
		layout #split;
		display graph background:#black type:opengl draw_env:false name:"Tejido Social"{
			graphics "network" refresh:false{
				loop vertex over: road_network.vertices{
					draw circle(10) at:vertex color: rgb (68, 151, 183,100);
				}
			}
			species road aspect:default;
			species block aspect:default;
			species walker aspect:default trace:5;
			species places aspect:interland;
			overlay position: { 10, 10 } size: { 180 #px, 180 #px } background: # black transparency: 0.5 border: #black rounded: true{
                float y <- 30#px;
                draw "Agents: " +  length(walker) at: { 40#px, y + 4#px } color: #white font: font("SansSerif", 15);
				draw square(flux_node_size) color:#limegreen at:{50#px, y+30#px};
				draw "Flux I/O" at:{50+30#px, y+30#px}  color: #white font: font("SansSerif", 15);
				draw square(flux_node_size) at:{50#px, y+60#px} color: rgb (232, 64, 126,255) border: #maroon;
				draw "Interland" at:{50+30#px, y+60#px}  color: #white font: font("SansSerif", 15);
				draw "Tejido Social" at:{600#px, 10#px} color: #white font: font("SansSerif", 25);
            }
            species flux_node aspect:default;
		}
		display network background:#black type:opengl name:"Network analysis"{
			graphics "nodes"{
            	point reference <- location;
            	int diameter <- 300;
            	int n <- 10;
            	float alpha <- 360/n;
            	draw circle(10) at:reference;
            	loop it from: 0 to:12{}
            	draw circle(10) at:location+{diameter*cos(alpha),diameter*sin(alpha)};
            }
		}
	}
	
}
experiment GUI type:gui{
	parameter "Roads_Knowledge" var: allowRoadsKnowledge  <- false;
	output{
		layout #split;
		display Main type:opengl ambient_light:50{
			species block aspect:default;
			species inhabitant aspect:default;
			species relationships aspect:default;
			species negRelationships aspect:default;
			species places aspect:default;
			species offender;
			overlay position: { 5, 5 } size: { 180 #px, 200 #px } background: # black transparency: 0.5 border: #black rounded: true
            {
				float y <- 30#px;
				loop type over: color_type.keys
				{
					draw circle(5#px) at: { 20#px, y } color: color_type[type] border: color_type[type]+1;
					draw string(type) at: { 40#px, y + 4#px } color: #white font: font("SansSerif", 12);
   					y <- y + 25#px;
               }
   				draw "Crimes: " +  totalCrimes at: { 40#px, y + 4#px } color: #white font: font("SansSerif", 15);
            }
		}
		display Output type:opengl{
			chart "Social Fabric" type: radar position:{5,5} background: # black x_serie_labels: [ "+ Encounters", "- Encounters", "+ Safety perception", "- Safety perception", "Segregation"] color:#white series_label_position: xaxis
			{
				data "Encounters" value: [encounters/maxEncounters,negEncounters/maxNegEncounters,0.1,0.1,0.1] color: # green;
			}
		}
		display Risk_Areas type:opengl{
			species cell aspect: crimeAttractiveAreas;
			species road aspect:default refresh:false;
		}
		
	}
}